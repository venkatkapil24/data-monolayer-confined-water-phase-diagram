<simulation verbosity='' threading='' mode=''>
   <help> This is the top level class that deals with the running of the simulation, including holding the simulation specific properties such as the time step and outputting the data. </help>
   <verbosity_help> The level of output on stdout. </verbosity_help>
   <threading_help> Whether multiple-systems execution should be parallel. Makes execution non-reproducible due to the random number generator being used from concurrent threads. </threading_help>
   <mode_help> What kind of simulation should be run. </mode_help>
   <verbosity_default> low </verbosity_default>
   <threading_default> True </threading_default>
   <mode_default> md </mode_default>
   <verbosity_options> ['quiet', 'low', 'medium', 'high', 'debug'] </verbosity_options>
   <mode_options> ['md', 'paratemp', 'static'] </mode_options>
   <verbosity_dtype> string </verbosity_dtype>
   <threading_dtype> boolean </threading_dtype>
   <mode_dtype> string </mode_dtype>
   <prng>
      <help> Deals with the pseudo-random number generator. </help>
      <seed>
         <help> This is the seed number used to generate the initial state of the random number generator. </help>
         <default> 12345 </default>
         <dtype> integer </dtype>
      </seed>
      <state shape='' mode=''>
         <help> Gives the state vector for the random number generator. Avoid directly modifying this unless you are very familiar with the inner workings of the algorithm used. </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [     12345 2003863422 2690739229 1915043646 1178839775 1127561115
             2079742408 4273798484 1166312027 3749681035 4196831410 4118597344
              287971995 1813410356  594308087  659474306 4150741082 1743137838
              884839837 2535984132 3982881906 2485184938 1369380702  249499538
             1112819378 3086659512   67624572  848241415 1969787103 3856266675
             1263083150 4280063370 3574353965 1040597063 2261670693 2420299142
              893247800 3883455293 3932784028 2944192226  789806728 3609179089
             1501254660 3049378596 1031906346 3659939519 2412600410 1222149863
             1441287918  862849916 3472090142 2753004708 4224592818 2341467658
              883841374  808357965 1538466713  618750769 2371378063  162894812
             3687322120 3924033940  183463889 2919560884 3606494222 2052466274
              792535121 1738545464 1278768321 2046873605 4055905754 1117085668
             1887658657 3858598249 3849777436 3671046278 2773875141  101190352
             3131413598  507298971  929924215 1297740356 1661371019 1462983365
              238138280 4233677213 1044322732 2539007283 3146124717 3976138084
             3499976957 2453428881 2085447515 1112469727 2786973172  587206765
             1187762273  864851521  447156487 1463252774 3451314631 3830773433
             3299140040 2725230718  993142100 2785980045 2032035285 1179164943
             3896117490 2554691714 3366990574 3644845296 3937109839  606604653
              217555315 2436775378  223523716  474904457  967604867 2888921382
             2903107500 1336313375 3712677968 1002267706  569480542 1792097427
             1576339480 4155544412 1394670587 3467785251 3608391970  678857608
             2552812844  510900651  699515901 2901391448 2259805706   42076593
             2220133471 2265196092 2966177026 4102306189 3050943380 1897472189
             1184007868 2903854626 1394012978  983121586 4024499918 2142977142
             1937476233 3600314431 2681758788  603129399 2629165901 3046176198
             2652035824 2302272535  930691559 3424745410  613517509  687825754
             2288213284 2417432225 2527996403 2025817530 2923288173 2268070258
             1355121112 2841140294 1327025022 2653438150 1709601280  284460050
             3215179208 2763062113 1410345407  485041831 2956763029  175359558
              145928274 2031710991 1929306940 3101052104 3978978922 1533516070
              619072541  509775148  648167192 3949903157  443321612 1872958075
             1234146530 2995272016 2141814812 3493466420 3869260407 1168843913
             1925853806 3016510866  604809880 3396511425 2714213716 1011751353
             1453533129 4112562869  483332252 1910049371 1369522258 1179634832
              904679175 3652644246  627276189 2342453446 3800052266 2727001092
              193291574 2068108583 1413705432 3906723192 2057450851 4265509511
               69083890 3442822233 2321107554 3869751489 2807674732 1972452681
              688961100  825923809 3793074859 3457060143 2172534596 3918884231
             3458980350 2162190012 3870701538 4243748274 1887119555 1052043129
             3985511597 3135326103  457374651 1614898362 2647773627 1427292146
             1556334293 1047586459 3224432415 1560826629  500295054 1183485953
             3954888956 1166404760  497236571  136165862  964718270 2585878519
             2805463467  223343024 3836840820 1106228728 1371802947 1648332305
             1753849176 3169760806 1956847934 3453998566 2013917541 2010562945
             2143803534 2628122746  180043880  338694681 3142944239 1390718100
             2829505757 3084276752  520801840 3941272071 1832065196  370692698
             4095781020 2071502550 1333312239 2066554627 1869827816  571986956
              271914460  917003501  815955875 1742706546 1265126531 2158346863
             3278703399 4076317275  776424928  200186505 1804945975  639053433
             3226671081 3086658175  546122111  425678666 2740587362 1916591633
             2001350018 1161040098 1690904003 1222555839  636391980  848115859
              352517687  196787180 1118925142  319440782 3761977922  760333794
             1700201832 4279850156 1478037835 3710545267  878583410 4102751805
              887268794  674360743 2272404265 2668028990 4219480308  574446012
              459146358   62187993  947152105 2655748666  201480550 2022628493
              473428108 3047216269 3726468285 1169452617 1932266428  282314726
             2027025684 2526080928 3705290306  221403646 3304616080 3259504218
             1658155897   21612469 3488524487  248871603 4157093119 2839266509
             1989176845  607377439   66444447 1063920416 1200356614   64263210
              189722618 3160897803 3487011575 1381863343 3868184338 3255028770
              346305395 4034255054 1495220049 1566952449 3881139570  519239688
             1691362460 1711372390 3335823641 2614131385 1242267711  131909615
             2359478725  312876030  745929394 2693999543 2858884327 3479696600
             2349453031 3285855962 3692404255 2296929935 1881261093 3695552441
             1012119528 2177546255  903123881 1434629174 3498281533 2559752705
              293863355 1863055700 3850034455 3310677619  321651648  949959761
             1615931015   55306865   42006825  509099970 3376282400  852414822
             2071082198 4164348268 2258600293 1996435006 1512437623 1856162091
             4228307248 2371157438 2121644236 1844617090 3635088209 3955776253
             3819951578 1388282178 4002405397 1747164245 3674317516  258933844
              241806030 3485115121 1651756326 3767193872 2620172589 4168214586
             1606820141 1226810381 1419388526 3228275326  960541189  804121262
              238466652 2947624963 3751770909 2560664207  473471067 4200190114
             1987869249 3024649469 3933653337 2350160961 3583410991 4140322333
             1504108952 1690362912  588688329 2019514642 4157493573 4006512741
             2168743942  599994205  400914043 1531745106  189959307  546625444
             2543573378  711086415 3816185083 1077634985 3615543066  710219696
              588220996 2650534569 4025565773 2127358109 3684123492 3784358012
              273531637 3166046596 2845079994 1354727285 3270401698 4212555876
              292080003 3099827600 2071875196  843111988 2381152360 1397908919
             2280294580 2813024181 1921747995 2881368619  906018071 2468145918
             1091408728 2175059210  380306966 3931451037 4158649414 1861701162
             1737743337 3780963451 3145565516 2986235835 3361316595 2583307943
             1222807057 2715328073 3208222865 1952767738 3825028611 2746075133
             2677039257 1072042534 3699736830 3047049938  690804242 2948471069
             3578430015 3854270385 2418910528 2889910033  860059527 2370201932
              876891088 4264835867 4225968772  269682768 2166692254 1369151643
             2604900562 2557330465   37363425 3214645720  179265302 4071443395
             2385028310 3356130747 2574455728 3251571027 1138392746 1303019154
             1543871771 2466244447 2169638607 3538324992 3171591247 1094388098
             3673611729  685303805 1168436725  789935977 2688438163 3928031068
              390568355 2012011128  380368103  507002958 2965184242  146515677
             2858425439 2846095328 3431383130 2626192974 2379196974 1278456207
             2102136122 1655885180 4209899911 3708229451   37337504 1484578393
             4037595890 3155506256 2476443798 2759858337 3828217229 1030545733
             3311783801 2173249379 2161538183 3835307964 1515186079 1640755611
             1291304456 4038053076 1474028059 2088116363 1842000572 1774889948
              570037629 2408931742  309330138  882573905 4053550405 1621347567
             3419224632 3082718874 2124782668 1511449014  701693577  741654372
              385353932  438609621 1502663011 3890089989 1230604986 2326712612
               82828380  638791339 3023564503 1823750506  197258393 1867463616
             1602477705 3067450893 3724229969 1294865857 3037878056 1527242747
             3100518924 1278875633  290120732 4083350905 1711951248  277493156]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </state>
      <has_gauss>
         <help> Determines whether there is a stored gaussian number or not. A value of 0 means there is none stored. </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </has_gauss>
      <gauss>
         <help> The stored Gaussian number. </help>
         <default> 0.0 </default>
         <dtype> float </dtype>
      </gauss>
      <set_pos>
         <help> Gives the position in the state array that the random number generator is reading from. </help>
         <default> 624 </default>
         <dtype> integer </dtype>
      </set_pos>
   </prng>
   <output prefix=''>
      <help> This class defines how properties, trajectories and checkpoints should be output during the simulation. May contain zero, one or many instances of properties, trajectory or checkpoint tags, each giving instructions on how one output file should be created and managed. </help>
      <prefix_help> A string that will be prepended to each output file name. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </prefix_help>
      <prefix_default> i-pi </prefix_default>
      <prefix_dtype> string </prefix_dtype>
      <properties shape='' mode='' filename='' stride='' flush=''>
         <help> Each of the properties tags specify how to create a file in which one or more properties are written, one line per frame.  </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <filename_help> A string to specify the name of the file that is output. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </filename_help>
         <stride_help> The number of steps between successive writes. </stride_help>
         <flush_help> How often should streams be flushed. 1 means each time, zero means never. </flush_help>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <filename_default> out </filename_default>
         <stride_default> 1 </stride_default>
         <flush_default> 1 </flush_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> string </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
         <filename_dtype> string </filename_dtype>
         <stride_dtype> integer </stride_dtype>
         <flush_dtype> integer </flush_dtype>
      </properties>
      <trajectory filename='' stride='' format='' cell_units='' bead='' flush=''>
         <help> Each of the trajectory tags specify how to create a trajectory file, containing a list of per-atom coordinate properties.  </help>
         <filename_help> A string to specify the name of the file that is output. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </filename_help>
         <stride_help> The number of steps between successive writes. </stride_help>
         <format_help> The output file format. </format_help>
         <cell_units_help> The units for the cell dimensions. </cell_units_help>
         <bead_help> Print out only the specified bead. A negative value means print only one every -(bead) beads, e.g. -2 means print just the even beads, -4 one every four and so on. </bead_help>
         <flush_help> How often should streams be flushed. 1 means each time, zero means never. </flush_help>
         <filename_default> traj </filename_default>
         <stride_default> 1 </stride_default>
         <format_default> xyz </format_default>
         <cell_units_default>  </cell_units_default>
         <bead_default> -1 </bead_default>
         <flush_default> 1 </flush_default>
         <format_options> ['xyz', 'pdb'] </format_options>
         <dtype> string </dtype>
         <filename_dtype> string </filename_dtype>
         <stride_dtype> integer </stride_dtype>
         <format_dtype> string </format_dtype>
         <cell_units_dtype> string </cell_units_dtype>
         <bead_dtype> integer </bead_dtype>
         <flush_dtype> integer </flush_dtype>
      </trajectory>
      <checkpoint filename='' stride='' overwrite=''>
         <help> Each of the checkpoint tags specify how to create a checkpoint file, which can be used to restart a simulation.  </help>
         <filename_help> A string to specify the name of the file that is output. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </filename_help>
         <stride_help> The number of steps between successive writes. </stride_help>
         <overwrite_help> This specifies whether or not each consecutive checkpoint file will overwrite the old one. </overwrite_help>
         <filename_default> restart </filename_default>
         <stride_default> 1 </stride_default>
         <overwrite_default> True </overwrite_default>
         <dtype> integer </dtype>
         <filename_dtype> string </filename_dtype>
         <stride_dtype> integer </stride_dtype>
         <overwrite_dtype> boolean </overwrite_dtype>
      </checkpoint>
   </output>
   <step>
      <help> The current simulation time step. </help>
      <default> 0 </default>
      <dtype> integer </dtype>
   </step>
   <total_steps>
      <help> The total number of steps that will be done. If 'step' is equal to or greater than 'total_steps', then the simulation will finish. </help>
      <default> 1000 </default>
      <dtype> integer </dtype>
   </total_steps>
   <total_time>
      <help> The maximum wall clock time (in seconds). </help>
      <default> 0 </default>
      <dtype> float </dtype>
   </total_time>
   <smotion mode=''>
      <help> Options for a 'super-motion' step between system replicas </help>
      <mode_help> Kind of smotion which should be performed. </mode_help>
      <mode_options> ['dummy', 'remd', 'metad', 'multi'] </mode_options>
      <mode_dtype> string </mode_dtype>
      <remd>
         <help> Option for REMD simulation </help>
         <stride>
            <help> Every how often to try exchanges (on average). </help>
            <default> 1.0 </default>
            <dtype> float </dtype>
         </stride>
         <krescale>
            <help> Rescale kinetic energy upon exchanges. </help>
            <default> True </default>
            <dtype> boolean </dtype>
         </krescale>
         <swapfile>
            <help> File to keep track of replica exchanges </help>
            <default> remd_idx </default>
            <dtype> string </dtype>
         </swapfile>
         <repindex shape='' mode=''>
            <help> List of current indices of the replicas compared to the starting indices </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </repindex>
      </remd>
      <metad>
         <help> Option for REMD simulation </help>
         <metaff shape='' mode=''>
            <help> List of names of forcefields that should do metadynamics. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> string </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </metaff>
      </metad>
      <smotion mode=''>
         <help> A smotion class that can be included as a member of a 'multi' Smotion. </help>
         <mode_help> Kind of smotion which should be performed. </mode_help>
         <mode_options> ['dummy', 'remd', 'metad', 'multi'] </mode_options>
         <mode_dtype> string </mode_dtype>
         <remd>
            <help> Option for REMD simulation </help>
            <stride>
               <help> Every how often to try exchanges (on average). </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </stride>
            <krescale>
               <help> Rescale kinetic energy upon exchanges. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </krescale>
            <swapfile>
               <help> File to keep track of replica exchanges </help>
               <default> remd_idx </default>
               <dtype> string </dtype>
            </swapfile>
            <repindex shape='' mode=''>
               <help> List of current indices of the replicas compared to the starting indices </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </repindex>
         </remd>
         <metad>
            <help> Option for REMD simulation </help>
            <metaff shape='' mode=''>
               <help> List of names of forcefields that should do metadynamics. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </metaff>
         </metad>
      </smotion>
   </smotion>
   <system prefix=''>
      <help> This is the class which holds all the data which represents a single state of the system. </help>
      <prefix_help> Prepend this string to output files generated for this system.  </prefix_help>
      <prefix_default>  </prefix_default>
      <prefix_dtype> string </prefix_dtype>
      <initialize nbeads=''>
         <help> Specifies the number of beads, and how the system should be initialized. </help>
         <nbeads_help> The number of beads. Will override any provision from inside the initializer. A ring polymer contraction scheme is used to scale down the number of beads if required. If instead the number of beads is scaled up, higher normal modes will be initialized to zero. </nbeads_help>
         <nbeads_dtype> integer </nbeads_dtype>
         <positions mode='' index='' bead=''>
            <help> Initializes atomic positions. Will take a 'units' attribute of dimension 'length' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </positions>
         <velocities mode='' index='' bead=''>
            <help> Initializes atomic velocities. Will take a 'units' attribute of dimension 'velocity' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. 'thermal' means that the data is to be generated from a Maxwell-Boltzmann distribution at the given temperature. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'chk', 'thermal'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </velocities>
         <momenta mode='' index='' bead=''>
            <help> Initializes atomic momenta. Will take a 'units' attribute of dimension 'momentum' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. 'thermal' means that the data is to be generated from a Maxwell-Boltzmann distribution at the given temperature. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'chk', 'thermal'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </momenta>
         <masses mode='' index='' bead=''>
            <help> Initializes atomic masses. Will take a 'units' attribute of dimension 'mass' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </masses>
         <labels mode='' index='' bead=''>
            <help> Initializes atomic labels </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </labels>
         <cell mode=''>
            <help> Initializes the configuration of the cell. Will take a 'units' attribute of dimension 'length' </help>
            <mode_help> This decides whether the system box is created from a cell parameter matrix, or from the side lengths and angles between them. If 'mode' is 'manual', then 'cell' takes a 9-elements vector containing the cell matrix (row-major).  The 1st element define lattice vector a, the 2nd, 5th elements define lattice vector b, and the 3rd, 6th, 9th elements define lattice vector c. The other elements are ignored. If 'mode' is 'abcABC', then 'cell' takes an array of 6 floats, the first three being the length of the sides of the system parallelopiped, and the last three being the angles (in degrees) between those sides. Angle A corresponds to the angle between sides b and c, and so on for B and C. If mode is 'abc', then this is the same as for 'abcABC', but the cell is assumed to be orthorhombic. 'pdb' and 'chk' read the cell from a PDB or a checkpoint file, respectively. </mode_help>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'pdb', 'chk', 'abc', 'abcABC'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
         </cell>
         <file mode='' bead='' cell_units=''>
            <help> Initializes everything possible for the given mode. Will take a 'units' attribute of dimension 'length'. The unit conversion will only be applied to the positions and cell parameters. The 'units' attribute is deprecated. Append a 'quantity{units}' to the comment line of the xyz or to the 'TITLE' tag of a pdb. </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. </mode_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <cell_units_help> The units for the cell dimensions. </cell_units_help>
            <mode_default> chk </mode_default>
            <bead_default> -1 </bead_default>
            <cell_units_default> automatic </cell_units_default>
            <mode_options> ['xyz', 'pdb', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <bead_dtype> integer </bead_dtype>
            <cell_units_dtype> string </cell_units_dtype>
         </file>
         <gle mode=''>
            <help> Initializes the additional momenta in a GLE thermostat. </help>
            <mode_help> 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <mode_default> manual </mode_default>
            <mode_options> ['chk', 'manual'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
         </gle>
      </initialize>
      <forces>
         <help> Deals with creating all the necessary forcefield objects. </help>
         <force nbeads='' weight='' fd_epsilon='' name='' forcefield=''>
            <help> The class that deals with how each forcefield contributes to the overall potential, force and virial calculation. </help>
            <nbeads_help> If the forcefield is to be evaluated on a contracted ring polymer, this gives the number of beads that are used. If not specified, the forcefield will be evaluated on the full ring polymer. </nbeads_help>
            <weight_help> A scaling factor for this forcefield, to be applied before adding the force calculated by this forcefield to the total force. </weight_help>
            <fd_epsilon_help> The finite displacement to be used for calculaing the Suzuki-Chin contribution of the force. If the value is negative, a centered finite-difference scheme will be used. [in bohr] </fd_epsilon_help>
            <name_help> An optional name to refer to this force component. </name_help>
            <forcefield_help> Mandatory. The name of the forcefield this force is referring to. </forcefield_help>
            <nbeads_default> 0 </nbeads_default>
            <weight_default> 1.0 </weight_default>
            <fd_epsilon_default> -0.001 </fd_epsilon_default>
            <name_default>  </name_default>
            <forcefield_default>  </forcefield_default>
            <nbeads_dtype> integer </nbeads_dtype>
            <weight_dtype> float </weight_dtype>
            <fd_epsilon_dtype> float </fd_epsilon_dtype>
            <name_dtype> string </name_dtype>
            <forcefield_dtype> string </forcefield_dtype>
            <mts_weights units='' shape='' mode=''>
               <help> The weight of force in each mts level starting from outer. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default>
                  [1.]
               </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </mts_weights>
         </force>
      </forces>
      <ensemble>
         <help> Holds all the information that is ensemble specific, such as the temperature and the external pressure. </help>
         <temperature units=''>
            <help> The temperature of the system. </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> temperature </dimension>
            <default> 1.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </temperature>
         <pressure units=''>
            <help> The external pressure. </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> pressure </dimension>
            <default> -1.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </pressure>
         <stress units='' shape='' mode=''>
            <help> The external stress. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> pressure </dimension>
            <default>
               [-1. -1. -1. -1. -1. -1. -1. -1. -1.]
            </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </stress>
         <eens units=''>
            <help> The ensemble contribution to the conserved quantity. </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> energy </dimension>
            <default> 0.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </eens>
         <bias>
            <help> Deals with creating all the necessary forcefield objects. </help>
            <force nbeads='' weight='' fd_epsilon='' name='' forcefield=''>
               <help> The class that deals with how each forcefield contributes to the overall potential, force and virial calculation. </help>
               <nbeads_help> If the forcefield is to be evaluated on a contracted ring polymer, this gives the number of beads that are used. If not specified, the forcefield will be evaluated on the full ring polymer. </nbeads_help>
               <weight_help> A scaling factor for this forcefield, to be applied before adding the force calculated by this forcefield to the total force. </weight_help>
               <fd_epsilon_help> The finite displacement to be used for calculaing the Suzuki-Chin contribution of the force. If the value is negative, a centered finite-difference scheme will be used. [in bohr] </fd_epsilon_help>
               <name_help> An optional name to refer to this force component. </name_help>
               <forcefield_help> Mandatory. The name of the forcefield this force is referring to. </forcefield_help>
               <nbeads_default> 0 </nbeads_default>
               <weight_default> 1.0 </weight_default>
               <fd_epsilon_default> -0.001 </fd_epsilon_default>
               <name_default>  </name_default>
               <forcefield_default>  </forcefield_default>
               <nbeads_dtype> integer </nbeads_dtype>
               <weight_dtype> float </weight_dtype>
               <fd_epsilon_dtype> float </fd_epsilon_dtype>
               <name_dtype> string </name_dtype>
               <forcefield_dtype> string </forcefield_dtype>
               <mts_weights units='' shape='' mode=''>
                  <help> The weight of force in each mts level starting from outer. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default>
                     [1.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </mts_weights>
            </force>
         </bias>
         <bias_weights shape='' mode=''>
            <help> Bias weights. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </bias_weights>
         <hamiltonian_weights shape='' mode=''>
            <help> Hamiltonian weights. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </hamiltonian_weights>
         <time units=''>
            <help> The internal time for this system </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> time </dimension>
            <default> 0.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </time>
      </ensemble>
      <motion mode=''>
         <help> Allow chosing the type of calculation to be performed. Holds all the information that is calculation specific, such as geometry optimization parameters, etc. </help>
         <mode_help> How atoms should be moved at each step in the simulatio. 'replay' means that a simulation is replayed from trajectories provided to i-PI. </mode_help>
         <mode_options> ['vibrations', 'minimize', 'replay', 'neb', 'dynamics', 'constrained_dynamics', 't_ramp', 'p_ramp', 'alchemy', 'atomswap', 'planetary', 'instanton', 'al-kmc', 'dummy', 'scp', 'normalmodes', 'multi'] </mode_options>
         <mode_dtype> string </mode_dtype>
         <fixcom>
            <help> This describes whether the centre of mass of the particles is fixed. </help>
            <default> True </default>
            <dtype> boolean </dtype>
         </fixcom>
         <fixatoms shape='' mode=''>
            <help> Indices of the atmoms that should be held fixed. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </fixatoms>
         <optimizer mode=''>
            <help> Option for geometry optimization </help>
            <mode_help> The geometry optimization algorithm to be used </mode_help>
            <mode_default> lbfgs </mode_default>
            <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <ls_options>
               <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
               <tolerance units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tolerance>
               <iter>
                  <help> Generic input value </help>
                  <default> 100 </default>
                  <dtype> integer </dtype>
               </iter>
               <step units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </step>
               <adaptive>
                  <help> Generic input value </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </adaptive>
            </ls_options>
            <exit_on_convergence>
               <help> Terminates the simulation when the convergence criteria are met. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </exit_on_convergence>
            <tolerances>
               <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-07 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 0.0001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <biggest_step>
               <help> The maximum step size for (L)-BFGS line minimizations. </help>
               <default> 100.0 </default>
               <dtype> float </dtype>
            </biggest_step>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 6 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <old_pos units='' shape='' mode=''>
               <help> The previous positions in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pos>
            <old_pot units='' shape='' mode=''>
               <help> The previous potential energy in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> energy </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pot>
            <old_force units='' shape='' mode=''>
               <help> The previous force in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_force>
            <old_direction shape='' mode=''>
               <help> The previous direction in a CG or SD optimization. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <invhessian_bfgs shape='' mode=''>
               <help> Approximate inverse Hessian for BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </invhessian_bfgs>
            <hessian_trm shape='' mode=''>
               <help> Approximate Hessian for trm, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </hessian_trm>
            <tr_trm units='' shape='' mode=''>
               <help> The trust radius in trm. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </tr_trm>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
         </optimizer>
         <neb_optimizer mode=''>
            <help> Option for geometry optimization </help>
            <mode_help> The geometry optimization algorithm to be used </mode_help>
            <mode_default> lbfgs </mode_default>
            <mode_options> ['sd', 'cg', 'bfgs', 'lbfgs'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <ls_options>
               <help> Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search,
                              grad_tolerance: stopping tolerance on gradient for
                              BFGS line search,
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
               <tolerance units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-06 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tolerance>
               <iter>
                  <help> Generic input value </help>
                  <default> 100 </default>
                  <dtype> integer </dtype>
               </iter>
               <step units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </step>
               <adaptive>
                  <help> Generic input value </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </adaptive>
            </ls_options>
            <tolerances>
               <help> Generic input value </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <old_force units='' shape='' mode=''>
               <help> The previous force in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_force>
            <old_direction shape='' mode=''>
               <help> The previous direction. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <biggest_step>
               <help> The maximum step size for (L)-BFGS line minimizations. </help>
               <default> 100.0 </default>
               <dtype> float </dtype>
            </biggest_step>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <invhessian_bfgs shape='' mode=''>
               <help> Approximate inverse Hessian for BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </invhessian_bfgs>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 5 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <endpoints>
               <help> Geometry optimization of endpoints </help>
               <optimize>
                  <help> Generic input value </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </optimize>
               <algorithm>
                  <help> Generic input value </help>
                  <default> bfgs </default>
                  <dtype> string </dtype>
               </algorithm>
            </endpoints>
            <spring>
               <help> Uniform or variable spring constants along the elastic band </help>
               <varsprings>
                  <help> Generic input value </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </varsprings>
               <kappa>
                  <help> Generic input value </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </kappa>
               <kappamax>
                  <help> Generic input value </help>
                  <default> 1.5 </default>
                  <dtype> float </dtype>
               </kappamax>
               <kappamin>
                  <help> Generic input value </help>
                  <default> 0.5 </default>
                  <dtype> float </dtype>
               </kappamin>
            </spring>
            <climb>
               <help> Use climbing image NEB </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </climb>
         </neb_optimizer>
         <dynamics mode='' splitting=''>
            <help> Option for (path integral) molecular dynamics </help>
            <mode_help> The ensemble that will be sampled during the simulation.  </mode_help>
            <splitting_help> The Louiville splitting used for sampling the target ensemble.  </splitting_help>
            <mode_default> nve </mode_default>
            <splitting_default> obabo </splitting_default>
            <mode_options> ['nve', 'nvt', 'npt', 'nst', 'sc', 'scnpt'] </mode_options>
            <splitting_options> ['obabo', 'baoab'] </splitting_options>
            <mode_dtype> string </mode_dtype>
            <splitting_dtype> string </splitting_dtype>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <barostat mode=''>
               <help> Simulates an external pressure bath. </help>
               <mode_help> The type of barostat.  Currently, only a 'isotropic' barostat is implemented, that combines
                                    ideas from the Bussi-Zykova-Parrinello barostat for classical MD with ideas from the
                                    Martyna-Hughes-Tuckerman centroid barostat for PIMD; see Ceriotti, More, Manolopoulos, Comp. Phys. Comm. 2013 for
                                    implementation details. </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <tau units=''>
                  <help> The time constant associated with the dynamics of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <p units='' shape='' mode=''>
                  <help> Momentum (or momenta) of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </p>
               <h0 units='' shape='' mode=''>
                  <help> Reference cell for Parrinello-Rahman-like barostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default>
                     [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </h0>
               <direction>
                  <help> define which elements of the h matrix will change. h matrix is defined as upper triangle matrix, in which each column stands for each cell vector a, b, c, respectively. option 'all' will relax all the martrix elements, option 'xx', 'yy', 'zz','xy', 'xz' and 'yz' change the element 11, 22, 33, 12, 13, 23 respectively. </help>
                  <default> all </default>
                  <options> ['all', 'xx', 'yy', 'zz', 'xy', 'xz', 'yz'] </options>
                  <dtype> string </dtype>
               </direction>
            </barostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
         </dynamics>
         <constrained_dynamics mode='' splitting=''>
            <help> Option for constrained classical molecular dynamics </help>
            <mode_help> The ensemble that will be sampled during the simulation.  </mode_help>
            <splitting_help> The integrator used for sampling the target ensemble.  </splitting_help>
            <mode_default> nve </mode_default>
            <splitting_default> baoab </splitting_default>
            <mode_options> ['nve', 'nvt'] </mode_options>
            <splitting_options> ['obabo', 'baoab'] </splitting_options>
            <mode_dtype> string </mode_dtype>
            <splitting_dtype> string </splitting_dtype>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <barostat mode=''>
               <help> Simulates an external pressure bath. </help>
               <mode_help> The type of barostat.  Currently, only a 'isotropic' barostat is implemented, that combines
                                    ideas from the Bussi-Zykova-Parrinello barostat for classical MD with ideas from the
                                    Martyna-Hughes-Tuckerman centroid barostat for PIMD; see Ceriotti, More, Manolopoulos, Comp. Phys. Comm. 2013 for
                                    implementation details. </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <tau units=''>
                  <help> The time constant associated with the dynamics of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <p units='' shape='' mode=''>
                  <help> Momentum (or momenta) of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </p>
               <h0 units='' shape='' mode=''>
                  <help> Reference cell for Parrinello-Rahman-like barostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default>
                     [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </h0>
               <direction>
                  <help> define which elements of the h matrix will change. h matrix is defined as upper triangle matrix, in which each column stands for each cell vector a, b, c, respectively. option 'all' will relax all the martrix elements, option 'xx', 'yy', 'zz','xy', 'xz' and 'yz' change the element 11, 22, 33, 12, 13, 23 respectively. </help>
                  <default> all </default>
                  <options> ['all', 'xx', 'yy', 'zz', 'xy', 'xz', 'yz'] </options>
                  <dtype> string </dtype>
               </direction>
            </barostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
            <nsteps_o>
               <help> The number of sub steps used in the evolution of the thermostat (used in function step_Oc). Relevant only for GLE thermostats </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nsteps_o>
            <nsteps_geo>
               <help> The number of sub steps used in the evolution of the geodesic flow (used in function step_Ag). </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nsteps_geo>
            <csolver>
               <help> Define a numerical method for computing the projection operators associated with the constraint. </help>
               <tolerance>
                  <help> Tolerance value used in the Quasi-Newton iteration scheme. </help>
                  <default> 0.0001 </default>
                  <dtype> float </dtype>
               </tolerance>
               <maxit>
                  <help> Maximum number of steps used in the Quasi-Newton iteration scheme. </help>
                  <default> 1000 </default>
                  <dtype> integer </dtype>
               </maxit>
               <norm_order>
                  <help> Order of norm used to determine termination of the Quasi-newton iteration. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </norm_order>
            </csolver>
            <constraint mode=''>
               <help> Define a constraint to be applied onto atoms </help>
               <mode_help> The type of constraint.  </mode_help>
               <mode_default> distance </mode_default>
               <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <atoms shape='' mode=''>
                  <help> List of atoms indices that are to be constrained. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </atoms>
               <values units='' shape='' mode=''>
                  <help> List of constraint lengths. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </values>
               <constraint mode=''>
                  <help> One or more constraints that have to be considered coupled </help>
                  <mode_help> The type of constraint.  </mode_help>
                  <mode_default> distance </mode_default>
                  <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <atoms shape='' mode=''>
                     <help> List of atoms indices that are to be constrained. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> integer </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </atoms>
                  <values units='' shape='' mode=''>
                     <help> List of constraint lengths. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </values>
               </constraint>
            </constraint>
         </constrained_dynamics>
         <file mode='' bead='' cell_units=''>
            <help> This describes the location to read a trajectory file from. </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. </mode_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <cell_units_help> The units for the cell dimensions. </cell_units_help>
            <default>  </default>
            <mode_default> chk </mode_default>
            <bead_default> -1 </bead_default>
            <cell_units_default> automatic </cell_units_default>
            <mode_options> ['xyz', 'pdb', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <bead_dtype> integer </bead_dtype>
            <cell_units_dtype> string </cell_units_dtype>
         </file>
         <vibrations mode=''>
            <help> Option for phonon computation </help>
            <mode_help> The algorithm to be used: finite differences (fd), normal modes finite differences (nmfd), and energy-scaled normal mode finite differences (enmfd). </mode_help>
            <mode_default> fd </mode_default>
            <mode_options> ['fd', 'nmfd', 'enmfd'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <pos_shift>
               <help> The finite displacement in position used to compute derivative of force. </help>
               <default> 0.01 </default>
               <dtype> float </dtype>
            </pos_shift>
            <energy_shift>
               <help> The finite displacement in energy used to compute derivative of force. </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </energy_shift>
            <output_shift>
               <help> Shift by the dynamical matrix diagonally before outputting. </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </output_shift>
            <prefix>
               <help> Prefix of the output files. </help>
               <default> phonons </default>
               <dtype> string </dtype>
            </prefix>
            <asr>
               <help> Removes the zero frequency vibrational modes depending on the symmerty of the system. </help>
               <default> none </default>
               <options> ['none', 'poly', 'lin', 'crystal'] </options>
               <dtype> string </dtype>
            </asr>
            <dynmat shape='' mode=''>
               <help> Portion of the dynamical matrix known up to now. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dynmat>
            <refdynmat shape='' mode=''>
               <help> Portion of the refined dynamical matrix known up to now. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </refdynmat>
         </vibrations>
         <normalmodes mode=''>
            <help> Option for solving the vibrational Schroedinger's equations in normal mode coordinates. </help>
            <mode_help> The algorithm to be used: independent mode framework (imf) and vibrational self consistent field (vscf). </mode_help>
            <mode_default> imf </mode_default>
            <mode_options> ['imf', 'vscf'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <prefix>
               <help> Prefix of the output files. </help>
               <default>  </default>
               <dtype> string </dtype>
            </prefix>
            <asr>
               <help> Removes the zero frequency vibrational modes depending on the symmetry of the system for general polyatomic molecules, and periodic crystal structures. </help>
               <default> none </default>
               <options> ['none', 'poly', 'crystal'] </options>
               <dtype> string </dtype>
            </asr>
            <dynmat shape='' mode=''>
               <help> Portion of the dynamical matrix known to the current point in the calculation. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dynmat>
            <nprim>
               <help> Number of primitive unit cells in the simulation cell. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </nprim>
            <fnmrms>
               <help> Fraction of harmonic RMS displacement used to sample along normal mode. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </fnmrms>
            <nevib>
               <help> Multiple of harm vibr energy up to which BO surface is sampled. </help>
               <default> 25.0 </default>
               <dtype> float </dtype>
            </nevib>
            <nint>
               <help> Integration points for Hamiltonian matrix elements. </help>
               <default> 101 </default>
               <dtype> integer </dtype>
            </nint>
            <pair_range shape='' mode=''>
               <help> The range of pair combinations of normal modes to be considered. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </pair_range>
            <nbasis>
               <help> Number of SHO states used as basis for anharmonic wvfn. </help>
               <default> 10 </default>
               <dtype> integer </dtype>
            </nbasis>
            <athresh units=''>
               <help> Convergence threshold for absolute error in vibr free energy per degree of freedom. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 3.6749322e-06 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </athresh>
            <ethresh>
               <help> Convergence thresh for fractional error in vibr free energy. </help>
               <default> 0.01 </default>
               <dtype> float </dtype>
            </ethresh>
            <alpha>
               <help> The fraction of mean field potential to mix with the result of the previous SCF iteration. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </alpha>
            <nkbt>
               <help> Threshold for (e - e_gs)/(kB T) of vibr state to be incl in the VSCF and partition function. </help>
               <default> 4.0 </default>
               <dtype> float </dtype>
            </nkbt>
            <nexc>
               <help> Minimum number of excited n-body states to calculate (also in MP2 correction). </help>
               <default> 5 </default>
               <dtype> integer </dtype>
            </nexc>
            <mptwo>
               <help> Flag determining whether MP2 correction is calculated. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </mptwo>
            <solve>
               <help> Flag determining whether the VSCF mean field Schroedinger's equation is solved. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </solve>
            <grid>
               <help> Flag determining whether the coupling potential is gridded or not. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </grid>
            <print_mftpot>
               <help> Flag determining whether MFT potentials are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_mftpot>
            <print_1b_map>
               <help> Flag determining whether the independent mode potentials are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_1b_map>
            <print_2b_map>
               <help> Flag determining whether the two body mapped coupling potentials are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_2b_map>
            <print_vib_density>
               <help> Flag determining whether the vibrational density (|psi|^2) are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_vib_density>
            <threebody>
               <help> Flag determining whether three-mode coupling terms are accounted for. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </threebody>
            <nparallel>
               <help> The number of forces evaluations per i-PI step. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nparallel>
         </normalmodes>
         <scp mode=''>
            <help> Option for self consistent phonons computation </help>
            <mode_help> The statistics to be used in the calculation of the free energy. Quantum (qn) or classical (cl) Boltzmann statistics. </mode_help>
            <mode_default> qn </mode_default>
            <mode_options> ['qn', 'cl'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <prefix>
               <help> Prefix of the output files. </help>
               <default>  </default>
               <dtype> string </dtype>
            </prefix>
            <asr>
               <help> The method used to project out zero modes coming from continuous symmetries: crystal removes the three translational modes; molecule removes the three rotational modes in addition to the translational ones. none keeps all the modes. </help>
               <default> none </default>
               <options> ['none', 'crystal', 'poly'] </options>
               <dtype> string </dtype>
            </asr>
            <random_type>
               <help> Chooses the type of random numbers. </help>
               <default> pseudo </default>
               <options> ['sobol', 'pseudo', 'file'] </options>
               <dtype> string </dtype>
            </random_type>
            <displace_mode>
               <help> The type of optimisation strategy for obtaining the mean position. sd stands for a steepest descent algorithm. ik stands for a Newton-Raphson scheme that requires the inverse of the force constant matrix iK. nmik stands for a Newton-Raphson scheme that only displaces along normal modes directions with statistically significant forces. rnmik same as nmik but performs several optimization steps using a reweighted sampling. </help>
               <default> nmik </default>
               <options> ['ik', 'sd', 'nmik', 'rnmik'] </options>
               <dtype> string </dtype>
            </displace_mode>
            <dynmat shape='' mode=''>
               <help> The dynamical matrix of the trial Hamiltonian. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dynmat>
            <max_steps>
               <help> Maximum number of Monte carlo steps per SCP iteration. </help>
               <dtype> integer </dtype>
            </max_steps>
            <max_iter>
               <help> Maximum number of SCP iterations. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </max_iter>
            <tau>
               <help> Step size along the gradient for the sd displace_mode </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </tau>
            <wthreshold>
               <help> Threshold on minimum Boltzmann weights before more statistics must be accumulated. </help>
               <default> 0.9 </default>
               <dtype> float </dtype>
            </wthreshold>
            <precheck>
               <help> Flag for checking statistical significance of forces before optimisation of mean position. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </precheck>
            <checkweights>
               <help> Flag for checking Boltzmann weights for whether more statistics are required. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </checkweights>
            <chop>
               <help> Threshold below which frequencies are set to zero. </help>
               <default> 1e-09 </default>
               <dtype> float </dtype>
            </chop>
            <nparallel>
               <help> The number of Monte Carlo forces to be evaluated (in parallel) per i-PI step. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nparallel>
            <batch_weight_exponent>
               <help> The exponent used to suppress low batch weights. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </batch_weight_exponent>
         </scp>
         <alchemy mode=''>
            <help> Option for alchemical exchanges </help>
            <mode_help>   </mode_help>
            <mode_default> dummy </mode_default>
            <mode_options> ['dummy'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <names shape='' mode=''>
               <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </names>
            <nxc>
               <help> The average number of exchanges per step to be attempted  </help>
               <default> 1 </default>
               <dtype> float </dtype>
            </nxc>
            <ealc>
               <help> The contribution to the conserved quantity for the alchemical exchanger </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </ealc>
         </alchemy>
         <atomswap mode=''>
            <help> Option for Monte Carlo atom swap </help>
            <mode_help>   </mode_help>
            <mode_default> dummy </mode_default>
            <mode_options> ['dummy'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <names shape='' mode=''>
               <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </names>
            <nxc>
               <help> The average number of exchanges per step to be attempted  </help>
               <default> 1 </default>
               <dtype> float </dtype>
            </nxc>
            <ealc>
               <help> The contribution to the conserved quantity for the atom swapper </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </ealc>
         </atomswap>
         <t_ramp>
            <help> Option for temperature ramp </help>
            <t_start units=''>
               <help> Initial temperature </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </t_start>
            <t_end units=''>
               <help> Final temperature </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </t_end>
            <logscale>
               <help> Change temperature on a logarihthmic scale. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </logscale>
            <total_steps>
               <help> Total number of steps for the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </total_steps>
            <current_step>
               <help> Current step along the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </current_step>
         </t_ramp>
         <p_ramp>
            <help> Option for pressure ramp </help>
            <p_start units=''>
               <help> Initial pressure </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> pressure </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </p_start>
            <p_end units=''>
               <help> Final pressure </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> pressure </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </p_end>
            <logscale>
               <help> Change pressure on a logarihthmic scale. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </logscale>
            <total_steps>
               <help> Total number of steps for the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </total_steps>
            <current_step>
               <help> Current step along the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </current_step>
         </p_ramp>
         <instanton mode=''>
            <help> Option for Instanton optimization </help>
            <mode_help> Defines whether it is an instanton rate or instanton tunneling splitting calculaion </mode_help>
            <mode_default> rate </mode_default>
            <mode_options> ['rate', 'splitting'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <tolerances>
               <help> Convergence criteria for optimization. </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-05 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 0.0001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <biggest_step>
               <help> The maximum step size during the optimization. </help>
               <default> 0.4 </default>
               <dtype> float </dtype>
            </biggest_step>
            <old_pos units='' shape='' mode=''>
               <help> The previous step positions during the optimization.  </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pos>
            <old_pot units='' shape='' mode=''>
               <help> The previous step potential energy during the optimization </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> energy </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pot>
            <old_force units='' shape='' mode=''>
               <help> The previous step force during the optimization </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_force>
            <opt>
               <help> The geometry optimization algorithm to be used.
                                            For small system sizes nichols is recomended. Lanczos is tailored for big bigger than nbeads*natoms >~38*64.
                                            NR works in both cases given that the initial guess is close to the optimized geometry.
                                            Finally lbfgs is used for tunneling splitting calculations.  </help>
               <default> None </default>
               <options> ['nichols', 'NR', 'lbfgs', 'lanczos', 'None'] </options>
               <dtype> string </dtype>
            </opt>
            <max_e units=''>
               <help> Evaluate the forces in a reduced ring polymer such that the potential energy between consecutive replicas is smaller that the provided value. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </max_e>
            <max_ms>
               <help> Evaluate the forces in a reduced ring polymer such that that mass-scaled distance in a.u. between consecutive replicas is  smaller that the provided value. </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </max_ms>
            <discretization shape='' mode=''>
               <help> Allows to specified non uniform time discretization as proposed in J. Chem. Phys. 134, 184107 (2011) </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </discretization>
            <alt_out>
               <help> Alternative output:Prints different formatting of outputs for geometry, hessian and bead potential energies.
                                               All quantities are also accessible from typical i-pi output infrastructure.
                                               Default to 1, which prints every step. -1 will suppress the output (except the last one).
                                               Any other positive number will set the frequency (in steps) with which the quantities are
                                               written to file.
                                               The instanton geometry is printed in xyz format and the distances are in angrstroms
                                               The hessian is printed in one line with the following format:
                                               h1_1,h2_1,...,hN_1,   h2_2,h2_2,hN_2,   ....   ,h1_d,h2_d,...,hN_d.
                                               Where N represents the total number of replicas, d the number of dimension of each replica (3*n_atoms) and
                                               hi_j means the row j of the physical hessian corresponding to the replica i.
                                               The physical hessian uses a convention according to the positions convention used in  i-pi.
                                               Example of 2 particles, the first two rows of the physical hessian reads:
                                               'H_x1_x1, H_x1_y1, H_x1_z1, H_x1_x2, H_x1_y2,H_x1_z2'
                                               'H_x2_x1, H_x2_y1, H_x2_z1, H_x2_x2, H_x2_y2,H_x2_z2'  </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </alt_out>
            <prefix>
               <help> Prefix of the output files. </help>
               <default> instanton </default>
               <dtype> string </dtype>
            </prefix>
            <delta>
               <help> Initial stretch amplitude. </help>
               <default> 0.1 </default>
               <dtype> float </dtype>
            </delta>
            <hessian_init>
               <help> How to initialize the hessian if it is not fully provided. </help>
               <default> false </default>
               <options> ['true', 'false'] </options>
               <dtype> string </dtype>
            </hessian_init>
            <hessian shape='' mode=''>
               <help> (Approximate) Hessian. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </hessian>
            <hessian_update>
               <help> How to update the hessian after each step. </help>
               <default> powell </default>
               <options> ['powell', 'recompute'] </options>
               <dtype> string </dtype>
            </hessian_update>
            <hessian_asr>
               <help> Removes the zero frequency vibrational modes depending on the symmerty of the system. </help>
               <default> none </default>
               <options> ['none', 'poly', 'crystal'] </options>
               <dtype> string </dtype>
            </hessian_asr>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
            <old_direction shape='' mode=''>
               <help> The previous direction in a CG or SD optimization. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                                       0 identity.
                                                       1 Use first member of position/gradient list.
                                                       2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 20 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <ls_options>
               <help> "Options for line search methods. Includes:
                                  tolerance: stopping tolerance for the search,
                                  iter: the maximum number of iterations,
                                  step: initial step for bracketing,
                                  adaptive: whether to update initial step.
                                   </help>
               <tolerance units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.2 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tolerance>
               <iter>
                  <help> Generic input value </help>
                  <default> 100 </default>
                  <dtype> integer </dtype>
               </iter>
            </ls_options>
            <energy_shift units=''>
               <help> Set the zero of energy. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </energy_shift>
            <hessian_final>
               <help> Decide if we are going to compute the final big-hessian by finite difference. </help>
               <default> false </default>
               <options> ['false', 'true'] </options>
               <dtype> string </dtype>
            </hessian_final>
         </instanton>
         <al6xxx_kmc mode=''>
            <help> Option for Al-6xxx KMC </help>
            <mode_help> The KMC algorithm to be used </mode_help>
            <mode_default> rfkmc </mode_default>
            <mode_options> ['rfkmc'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <geop mode=''>
               <help> Option for geometry optimization step </help>
               <mode_help> The geometry optimization algorithm to be used </mode_help>
               <mode_default> lbfgs </mode_default>
               <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ls_options>
                  <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
                  <step units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </step>
                  <adaptive>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </adaptive>
               </ls_options>
               <exit_on_convergence>
                  <help> Terminates the simulation when the convergence criteria are met. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </exit_on_convergence>
               <tolerances>
                  <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-07 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <biggest_step>
                  <help> The maximum step size for (L)-BFGS line minimizations. </help>
                  <default> 100.0 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 6 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <old_pos units='' shape='' mode=''>
                  <help> The previous positions in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pos>
               <old_pot units='' shape='' mode=''>
                  <help> The previous potential energy in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pot>
               <old_force units='' shape='' mode=''>
                  <help> The previous force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <old_direction shape='' mode=''>
                  <help> The previous direction in a CG or SD optimization. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <invhessian_bfgs shape='' mode=''>
                  <help> Approximate inverse Hessian for BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </invhessian_bfgs>
               <hessian_trm shape='' mode=''>
                  <help> Approximate Hessian for trm, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian_trm>
               <tr_trm units='' shape='' mode=''>
                  <help> The trust radius in trm. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </tr_trm>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
            </geop>
            <nstep>
               <help> The number of optimization steps. </help>
               <default> 10 </default>
               <dtype> integer </dtype>
            </nstep>
            <a0 units=''>
               <help> FCC lattice parameter  </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> length </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </a0>
            <diffusion_barrier_al units=''>
               <help> Barrier for vacancy diffusion in pure Al. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.01 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_barrier_al>
            <diffusion_prefactor_al units=''>
               <help> Prefactor for vacancy diffusion in pure Al. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> frequency </dimension>
               <default> 2.4188843e-05 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_prefactor_al>
            <diffusion_barrier_mg units=''>
               <help> Barrier for vacancy-assisted diffusion of Mg. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_barrier_mg>
            <diffusion_prefactor_mg units=''>
               <help> Prefactor for vacancy-assisted diffusion of Mg. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> frequency </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_prefactor_mg>
            <diffusion_barrier_si units=''>
               <help> Barrier for vacancy-assisted diffusion of Si. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_barrier_si>
            <diffusion_prefactor_si units=''>
               <help> Prefactor for vacancy-assisted diffusion of Si. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> frequency </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_prefactor_si>
            <neval>
               <help> The number of parallel force evaluators. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </neval>
            <ncell>
               <help> The number of repeat cells in each direction. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </ncell>
            <nvac>
               <help> The number of vacancies. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </nvac>
            <nsi>
               <help> The number of silicon atoms. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </nsi>
            <nmg>
               <help> The number of magnesium atoms. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </nmg>
            <idx shape='' mode=''>
               <help> The position of the atoms on the lattice, relative to the canonical ordering. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </idx>
            <tottime units=''>
               <help> Total KMC time elapsed  </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </tottime>
            <ecache_file>
               <help> Filename for storing/loading energy cache </help>
               <default>  </default>
               <dtype> string </dtype>
            </ecache_file>
            <qcache_file>
               <help> Filename for storing/loading positions cache </help>
               <default>  </default>
               <dtype> string </dtype>
            </qcache_file>
            <max_cache_len>
               <help> Maximum cache length before oldest entry is deleted </help>
               <default> 1000 </default>
               <dtype> integer </dtype>
            </max_cache_len>
         </al6xxx_kmc>
         <planetary mode=''>
            <help> Option for planetary model calculator </help>
            <mode_help> The constrained-centroid sampling mode.  </mode_help>
            <mode_default> md </mode_default>
            <mode_options> ['md'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
            <nsamples>
               <help> Number of samples to accumulate for each planetary step. </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </nsamples>
            <stride>
               <help> How often the planetary calculation should actually be triggered. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </stride>
            <nbeads>
               <help> Number of beads for centroid-constrained dynamics (default same as master trajectory) </help>
               <default> -1 </default>
               <dtype> integer </dtype>
            </nbeads>
            <screen units=''>
               <help> Screening parameter for path-integral frequency matrix. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> length </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </screen>
         </planetary>
         <motion mode=''>
            <help> A motion class that can be included as a member of a 'multi' integrator. </help>
            <mode_help> How atoms should be moved at each step in the simulatio. 'replay' means that a simulation is replayed from trajectories provided to i-PI. </mode_help>
            <mode_options> ['vibrations', 'minimize', 'replay', 'neb', 'dynamics', 'constrained_dynamics', 't_ramp', 'p_ramp', 'alchemy', 'atomswap', 'planetary', 'instanton', 'al-kmc', 'dummy', 'scp', 'normalmodes', 'multi'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <fixcom>
               <help> This describes whether the centre of mass of the particles is fixed. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </fixcom>
            <fixatoms shape='' mode=''>
               <help> Indices of the atmoms that should be held fixed. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </fixatoms>
            <optimizer mode=''>
               <help> Option for geometry optimization </help>
               <mode_help> The geometry optimization algorithm to be used </mode_help>
               <mode_default> lbfgs </mode_default>
               <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ls_options>
                  <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
                  <step units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </step>
                  <adaptive>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </adaptive>
               </ls_options>
               <exit_on_convergence>
                  <help> Terminates the simulation when the convergence criteria are met. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </exit_on_convergence>
               <tolerances>
                  <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-07 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <biggest_step>
                  <help> The maximum step size for (L)-BFGS line minimizations. </help>
                  <default> 100.0 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 6 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <old_pos units='' shape='' mode=''>
                  <help> The previous positions in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pos>
               <old_pot units='' shape='' mode=''>
                  <help> The previous potential energy in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pot>
               <old_force units='' shape='' mode=''>
                  <help> The previous force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <old_direction shape='' mode=''>
                  <help> The previous direction in a CG or SD optimization. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <invhessian_bfgs shape='' mode=''>
                  <help> Approximate inverse Hessian for BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </invhessian_bfgs>
               <hessian_trm shape='' mode=''>
                  <help> Approximate Hessian for trm, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian_trm>
               <tr_trm units='' shape='' mode=''>
                  <help> The trust radius in trm. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </tr_trm>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
            </optimizer>
            <neb_optimizer mode=''>
               <help> Option for geometry optimization </help>
               <mode_help> The geometry optimization algorithm to be used </mode_help>
               <mode_default> lbfgs </mode_default>
               <mode_options> ['sd', 'cg', 'bfgs', 'lbfgs'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ls_options>
                  <help> Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search,
                              grad_tolerance: stopping tolerance on gradient for
                              BFGS line search,
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-06 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
                  <step units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </step>
                  <adaptive>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </adaptive>
               </ls_options>
               <tolerances>
                  <help> Generic input value </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <old_force units='' shape='' mode=''>
                  <help> The previous force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <old_direction shape='' mode=''>
                  <help> The previous direction. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <biggest_step>
                  <help> The maximum step size for (L)-BFGS line minimizations. </help>
                  <default> 100.0 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <invhessian_bfgs shape='' mode=''>
                  <help> Approximate inverse Hessian for BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </invhessian_bfgs>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 5 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <endpoints>
                  <help> Geometry optimization of endpoints </help>
                  <optimize>
                     <help> Generic input value </help>
                     <default> True </default>
                     <dtype> boolean </dtype>
                  </optimize>
                  <algorithm>
                     <help> Generic input value </help>
                     <default> bfgs </default>
                     <dtype> string </dtype>
                  </algorithm>
               </endpoints>
               <spring>
                  <help> Uniform or variable spring constants along the elastic band </help>
                  <varsprings>
                     <help> Generic input value </help>
                     <default> False </default>
                     <dtype> boolean </dtype>
                  </varsprings>
                  <kappa>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </kappa>
                  <kappamax>
                     <help> Generic input value </help>
                     <default> 1.5 </default>
                     <dtype> float </dtype>
                  </kappamax>
                  <kappamin>
                     <help> Generic input value </help>
                     <default> 0.5 </default>
                     <dtype> float </dtype>
                  </kappamin>
               </spring>
               <climb>
                  <help> Use climbing image NEB </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </climb>
            </neb_optimizer>
            <dynamics mode='' splitting=''>
               <help> Option for (path integral) molecular dynamics </help>
               <mode_help> The ensemble that will be sampled during the simulation.  </mode_help>
               <splitting_help> The Louiville splitting used for sampling the target ensemble.  </splitting_help>
               <mode_default> nve </mode_default>
               <splitting_default> obabo </splitting_default>
               <mode_options> ['nve', 'nvt', 'npt', 'nst', 'sc', 'scnpt'] </mode_options>
               <splitting_options> ['obabo', 'baoab'] </splitting_options>
               <mode_dtype> string </mode_dtype>
               <splitting_dtype> string </splitting_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <barostat mode=''>
                  <help> Simulates an external pressure bath. </help>
                  <mode_help> The type of barostat.  Currently, only a 'isotropic' barostat is implemented, that combines
                                    ideas from the Bussi-Zykova-Parrinello barostat for classical MD with ideas from the
                                    Martyna-Hughes-Tuckerman centroid barostat for PIMD; see Ceriotti, More, Manolopoulos, Comp. Phys. Comm. 2013 for
                                    implementation details. </mode_help>
                  <mode_default> dummy </mode_default>
                  <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <thermostat mode=''>
                     <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                     <thermostat mode=''>
                        <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                        <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                        <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                        <mode_dtype> string </mode_dtype>
                        <ethermo units=''>
                           <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> energy </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </ethermo>
                        <tau units=''>
                           <help> The friction coefficient for white noise thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </tau>
                        <pile_lambda>
                           <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                           <default> 1.0 </default>
                           <dtype> float </dtype>
                        </pile_lambda>
                        <A units='' shape='' mode=''>
                           <help> The friction matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> frequency </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </A>
                        <C units='' shape='' mode=''>
                           <help> The covariance matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> temperature </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </C>
                        <s units='' shape='' mode=''>
                           <help> Input values for the additional momenta in GLE. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> ms-momentum </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </s>
                        <intau units=''>
                           <help> The inherent noise time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </intau>
                        <idtau units=''>
                           <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </idtau>
                        <apat units=''>
                           <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </apat>
                        <flip>
                           <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                           <default> rescale </default>
                           <dtype> string </dtype>
                        </flip>
                     </thermostat>
                  </thermostat>
                  <tau units=''>
                     <help> The time constant associated with the dynamics of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 1.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <p units='' shape='' mode=''>
                     <help> Momentum (or momenta) of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </p>
                  <h0 units='' shape='' mode=''>
                     <help> Reference cell for Parrinello-Rahman-like barostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default>
                        [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                     </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </h0>
                  <direction>
                     <help> define which elements of the h matrix will change. h matrix is defined as upper triangle matrix, in which each column stands for each cell vector a, b, c, respectively. option 'all' will relax all the martrix elements, option 'xx', 'yy', 'zz','xy', 'xz' and 'yz' change the element 11, 22, 33, 12, 13, 23 respectively. </help>
                     <default> all </default>
                     <options> ['all', 'xx', 'yy', 'zz', 'xy', 'xz', 'yz'] </options>
                     <dtype> string </dtype>
                  </direction>
               </barostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
            </dynamics>
            <constrained_dynamics mode='' splitting=''>
               <help> Option for constrained classical molecular dynamics </help>
               <mode_help> The ensemble that will be sampled during the simulation.  </mode_help>
               <splitting_help> The integrator used for sampling the target ensemble.  </splitting_help>
               <mode_default> nve </mode_default>
               <splitting_default> baoab </splitting_default>
               <mode_options> ['nve', 'nvt'] </mode_options>
               <splitting_options> ['obabo', 'baoab'] </splitting_options>
               <mode_dtype> string </mode_dtype>
               <splitting_dtype> string </splitting_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <barostat mode=''>
                  <help> Simulates an external pressure bath. </help>
                  <mode_help> The type of barostat.  Currently, only a 'isotropic' barostat is implemented, that combines
                                    ideas from the Bussi-Zykova-Parrinello barostat for classical MD with ideas from the
                                    Martyna-Hughes-Tuckerman centroid barostat for PIMD; see Ceriotti, More, Manolopoulos, Comp. Phys. Comm. 2013 for
                                    implementation details. </mode_help>
                  <mode_default> dummy </mode_default>
                  <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <thermostat mode=''>
                     <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                     <thermostat mode=''>
                        <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                        <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                        <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                        <mode_dtype> string </mode_dtype>
                        <ethermo units=''>
                           <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> energy </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </ethermo>
                        <tau units=''>
                           <help> The friction coefficient for white noise thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </tau>
                        <pile_lambda>
                           <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                           <default> 1.0 </default>
                           <dtype> float </dtype>
                        </pile_lambda>
                        <A units='' shape='' mode=''>
                           <help> The friction matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> frequency </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </A>
                        <C units='' shape='' mode=''>
                           <help> The covariance matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> temperature </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </C>
                        <s units='' shape='' mode=''>
                           <help> Input values for the additional momenta in GLE. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> ms-momentum </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </s>
                        <intau units=''>
                           <help> The inherent noise time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </intau>
                        <idtau units=''>
                           <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </idtau>
                        <apat units=''>
                           <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </apat>
                        <flip>
                           <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                           <default> rescale </default>
                           <dtype> string </dtype>
                        </flip>
                     </thermostat>
                  </thermostat>
                  <tau units=''>
                     <help> The time constant associated with the dynamics of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 1.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <p units='' shape='' mode=''>
                     <help> Momentum (or momenta) of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </p>
                  <h0 units='' shape='' mode=''>
                     <help> Reference cell for Parrinello-Rahman-like barostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default>
                        [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                     </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </h0>
                  <direction>
                     <help> define which elements of the h matrix will change. h matrix is defined as upper triangle matrix, in which each column stands for each cell vector a, b, c, respectively. option 'all' will relax all the martrix elements, option 'xx', 'yy', 'zz','xy', 'xz' and 'yz' change the element 11, 22, 33, 12, 13, 23 respectively. </help>
                     <default> all </default>
                     <options> ['all', 'xx', 'yy', 'zz', 'xy', 'xz', 'yz'] </options>
                     <dtype> string </dtype>
                  </direction>
               </barostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
               <nsteps_o>
                  <help> The number of sub steps used in the evolution of the thermostat (used in function step_Oc). Relevant only for GLE thermostats </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nsteps_o>
               <nsteps_geo>
                  <help> The number of sub steps used in the evolution of the geodesic flow (used in function step_Ag). </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nsteps_geo>
               <csolver>
                  <help> Define a numerical method for computing the projection operators associated with the constraint. </help>
                  <tolerance>
                     <help> Tolerance value used in the Quasi-Newton iteration scheme. </help>
                     <default> 0.0001 </default>
                     <dtype> float </dtype>
                  </tolerance>
                  <maxit>
                     <help> Maximum number of steps used in the Quasi-Newton iteration scheme. </help>
                     <default> 1000 </default>
                     <dtype> integer </dtype>
                  </maxit>
                  <norm_order>
                     <help> Order of norm used to determine termination of the Quasi-newton iteration. </help>
                     <default> 2 </default>
                     <dtype> integer </dtype>
                  </norm_order>
               </csolver>
               <constraint mode=''>
                  <help> Define a constraint to be applied onto atoms </help>
                  <mode_help> The type of constraint.  </mode_help>
                  <mode_default> distance </mode_default>
                  <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <atoms shape='' mode=''>
                     <help> List of atoms indices that are to be constrained. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> integer </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </atoms>
                  <values units='' shape='' mode=''>
                     <help> List of constraint lengths. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </values>
                  <constraint mode=''>
                     <help> One or more constraints that have to be considered coupled </help>
                     <mode_help> The type of constraint.  </mode_help>
                     <mode_default> distance </mode_default>
                     <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <atoms shape='' mode=''>
                        <help> List of atoms indices that are to be constrained. </help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <default> [ ] </default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> integer </dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </atoms>
                     <values units='' shape='' mode=''>
                        <help> List of constraint lengths. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> length </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </values>
                  </constraint>
               </constraint>
            </constrained_dynamics>
            <file mode='' bead='' cell_units=''>
               <help> This describes the location to read a trajectory file from. </help>
               <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. </mode_help>
               <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
               <cell_units_help> The units for the cell dimensions. </cell_units_help>
               <default>  </default>
               <mode_default> chk </mode_default>
               <bead_default> -1 </bead_default>
               <cell_units_default> automatic </cell_units_default>
               <mode_options> ['xyz', 'pdb', 'chk'] </mode_options>
               <dtype> string </dtype>
               <mode_dtype> string </mode_dtype>
               <bead_dtype> integer </bead_dtype>
               <cell_units_dtype> string </cell_units_dtype>
            </file>
            <vibrations mode=''>
               <help> Option for phonon computation </help>
               <mode_help> The algorithm to be used: finite differences (fd), normal modes finite differences (nmfd), and energy-scaled normal mode finite differences (enmfd). </mode_help>
               <mode_default> fd </mode_default>
               <mode_options> ['fd', 'nmfd', 'enmfd'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <pos_shift>
                  <help> The finite displacement in position used to compute derivative of force. </help>
                  <default> 0.01 </default>
                  <dtype> float </dtype>
               </pos_shift>
               <energy_shift>
                  <help> The finite displacement in energy used to compute derivative of force. </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </energy_shift>
               <output_shift>
                  <help> Shift by the dynamical matrix diagonally before outputting. </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </output_shift>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default> phonons </default>
                  <dtype> string </dtype>
               </prefix>
               <asr>
                  <help> Removes the zero frequency vibrational modes depending on the symmerty of the system. </help>
                  <default> none </default>
                  <options> ['none', 'poly', 'lin', 'crystal'] </options>
                  <dtype> string </dtype>
               </asr>
               <dynmat shape='' mode=''>
                  <help> Portion of the dynamical matrix known up to now. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </dynmat>
               <refdynmat shape='' mode=''>
                  <help> Portion of the refined dynamical matrix known up to now. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </refdynmat>
            </vibrations>
            <normalmodes mode=''>
               <help> Option for solving the vibrational Schroedinger's equations in normal mode coordinates. </help>
               <mode_help> The algorithm to be used: independent mode framework (imf) and vibrational self consistent field (vscf). </mode_help>
               <mode_default> imf </mode_default>
               <mode_options> ['imf', 'vscf'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </prefix>
               <asr>
                  <help> Removes the zero frequency vibrational modes depending on the symmetry of the system for general polyatomic molecules, and periodic crystal structures. </help>
                  <default> none </default>
                  <options> ['none', 'poly', 'crystal'] </options>
                  <dtype> string </dtype>
               </asr>
               <dynmat shape='' mode=''>
                  <help> Portion of the dynamical matrix known to the current point in the calculation. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </dynmat>
               <nprim>
                  <help> Number of primitive unit cells in the simulation cell. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </nprim>
               <fnmrms>
                  <help> Fraction of harmonic RMS displacement used to sample along normal mode. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </fnmrms>
               <nevib>
                  <help> Multiple of harm vibr energy up to which BO surface is sampled. </help>
                  <default> 25.0 </default>
                  <dtype> float </dtype>
               </nevib>
               <nint>
                  <help> Integration points for Hamiltonian matrix elements. </help>
                  <default> 101 </default>
                  <dtype> integer </dtype>
               </nint>
               <pair_range shape='' mode=''>
                  <help> The range of pair combinations of normal modes to be considered. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </pair_range>
               <nbasis>
                  <help> Number of SHO states used as basis for anharmonic wvfn. </help>
                  <default> 10 </default>
                  <dtype> integer </dtype>
               </nbasis>
               <athresh units=''>
                  <help> Convergence threshold for absolute error in vibr free energy per degree of freedom. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 3.6749322e-06 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </athresh>
               <ethresh>
                  <help> Convergence thresh for fractional error in vibr free energy. </help>
                  <default> 0.01 </default>
                  <dtype> float </dtype>
               </ethresh>
               <alpha>
                  <help> The fraction of mean field potential to mix with the result of the previous SCF iteration. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </alpha>
               <nkbt>
                  <help> Threshold for (e - e_gs)/(kB T) of vibr state to be incl in the VSCF and partition function. </help>
                  <default> 4.0 </default>
                  <dtype> float </dtype>
               </nkbt>
               <nexc>
                  <help> Minimum number of excited n-body states to calculate (also in MP2 correction). </help>
                  <default> 5 </default>
                  <dtype> integer </dtype>
               </nexc>
               <mptwo>
                  <help> Flag determining whether MP2 correction is calculated. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </mptwo>
               <solve>
                  <help> Flag determining whether the VSCF mean field Schroedinger's equation is solved. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </solve>
               <grid>
                  <help> Flag determining whether the coupling potential is gridded or not. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </grid>
               <print_mftpot>
                  <help> Flag determining whether MFT potentials are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_mftpot>
               <print_1b_map>
                  <help> Flag determining whether the independent mode potentials are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_1b_map>
               <print_2b_map>
                  <help> Flag determining whether the two body mapped coupling potentials are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_2b_map>
               <print_vib_density>
                  <help> Flag determining whether the vibrational density (|psi|^2) are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_vib_density>
               <threebody>
                  <help> Flag determining whether three-mode coupling terms are accounted for. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </threebody>
               <nparallel>
                  <help> The number of forces evaluations per i-PI step. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nparallel>
            </normalmodes>
            <scp mode=''>
               <help> Option for self consistent phonons computation </help>
               <mode_help> The statistics to be used in the calculation of the free energy. Quantum (qn) or classical (cl) Boltzmann statistics. </mode_help>
               <mode_default> qn </mode_default>
               <mode_options> ['qn', 'cl'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </prefix>
               <asr>
                  <help> The method used to project out zero modes coming from continuous symmetries: crystal removes the three translational modes; molecule removes the three rotational modes in addition to the translational ones. none keeps all the modes. </help>
                  <default> none </default>
                  <options> ['none', 'crystal', 'poly'] </options>
                  <dtype> string </dtype>
               </asr>
               <random_type>
                  <help> Chooses the type of random numbers. </help>
                  <default> pseudo </default>
                  <options> ['sobol', 'pseudo', 'file'] </options>
                  <dtype> string </dtype>
               </random_type>
               <displace_mode>
                  <help> The type of optimisation strategy for obtaining the mean position. sd stands for a steepest descent algorithm. ik stands for a Newton-Raphson scheme that requires the inverse of the force constant matrix iK. nmik stands for a Newton-Raphson scheme that only displaces along normal modes directions with statistically significant forces. rnmik same as nmik but performs several optimization steps using a reweighted sampling. </help>
                  <default> nmik </default>
                  <options> ['ik', 'sd', 'nmik', 'rnmik'] </options>
                  <dtype> string </dtype>
               </displace_mode>
               <dynmat shape='' mode=''>
                  <help> The dynamical matrix of the trial Hamiltonian. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </dynmat>
               <max_steps>
                  <help> Maximum number of Monte carlo steps per SCP iteration. </help>
                  <dtype> integer </dtype>
               </max_steps>
               <max_iter>
                  <help> Maximum number of SCP iterations. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </max_iter>
               <tau>
                  <help> Step size along the gradient for the sd displace_mode </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </tau>
               <wthreshold>
                  <help> Threshold on minimum Boltzmann weights before more statistics must be accumulated. </help>
                  <default> 0.9 </default>
                  <dtype> float </dtype>
               </wthreshold>
               <precheck>
                  <help> Flag for checking statistical significance of forces before optimisation of mean position. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </precheck>
               <checkweights>
                  <help> Flag for checking Boltzmann weights for whether more statistics are required. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </checkweights>
               <chop>
                  <help> Threshold below which frequencies are set to zero. </help>
                  <default> 1e-09 </default>
                  <dtype> float </dtype>
               </chop>
               <nparallel>
                  <help> The number of Monte Carlo forces to be evaluated (in parallel) per i-PI step. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nparallel>
               <batch_weight_exponent>
                  <help> The exponent used to suppress low batch weights. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </batch_weight_exponent>
            </scp>
            <alchemy mode=''>
               <help> Option for alchemical exchanges </help>
               <mode_help>   </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <names shape='' mode=''>
                  <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </names>
               <nxc>
                  <help> The average number of exchanges per step to be attempted  </help>
                  <default> 1 </default>
                  <dtype> float </dtype>
               </nxc>
               <ealc>
                  <help> The contribution to the conserved quantity for the alchemical exchanger </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </ealc>
            </alchemy>
            <atomswap mode=''>
               <help> Option for Monte Carlo atom swap </help>
               <mode_help>   </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <names shape='' mode=''>
                  <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </names>
               <nxc>
                  <help> The average number of exchanges per step to be attempted  </help>
                  <default> 1 </default>
                  <dtype> float </dtype>
               </nxc>
               <ealc>
                  <help> The contribution to the conserved quantity for the atom swapper </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </ealc>
            </atomswap>
            <t_ramp>
               <help> Option for temperature ramp </help>
               <t_start units=''>
                  <help> Initial temperature </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </t_start>
               <t_end units=''>
                  <help> Final temperature </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </t_end>
               <logscale>
                  <help> Change temperature on a logarihthmic scale. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </logscale>
               <total_steps>
                  <help> Total number of steps for the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </total_steps>
               <current_step>
                  <help> Current step along the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </current_step>
            </t_ramp>
            <p_ramp>
               <help> Option for pressure ramp </help>
               <p_start units=''>
                  <help> Initial pressure </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> pressure </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </p_start>
               <p_end units=''>
                  <help> Final pressure </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> pressure </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </p_end>
               <logscale>
                  <help> Change pressure on a logarihthmic scale. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </logscale>
               <total_steps>
                  <help> Total number of steps for the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </total_steps>
               <current_step>
                  <help> Current step along the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </current_step>
            </p_ramp>
            <instanton mode=''>
               <help> Option for Instanton optimization </help>
               <mode_help> Defines whether it is an instanton rate or instanton tunneling splitting calculaion </mode_help>
               <mode_default> rate </mode_default>
               <mode_options> ['rate', 'splitting'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <tolerances>
                  <help> Convergence criteria for optimization. </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-05 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <biggest_step>
                  <help> The maximum step size during the optimization. </help>
                  <default> 0.4 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <old_pos units='' shape='' mode=''>
                  <help> The previous step positions during the optimization.  </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pos>
               <old_pot units='' shape='' mode=''>
                  <help> The previous step potential energy during the optimization </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pot>
               <old_force units='' shape='' mode=''>
                  <help> The previous step force during the optimization </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <opt>
                  <help> The geometry optimization algorithm to be used.
                                            For small system sizes nichols is recomended. Lanczos is tailored for big bigger than nbeads*natoms >~38*64.
                                            NR works in both cases given that the initial guess is close to the optimized geometry.
                                            Finally lbfgs is used for tunneling splitting calculations.  </help>
                  <default> None </default>
                  <options> ['nichols', 'NR', 'lbfgs', 'lanczos', 'None'] </options>
                  <dtype> string </dtype>
               </opt>
               <max_e units=''>
                  <help> Evaluate the forces in a reduced ring polymer such that the potential energy between consecutive replicas is smaller that the provided value. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </max_e>
               <max_ms>
                  <help> Evaluate the forces in a reduced ring polymer such that that mass-scaled distance in a.u. between consecutive replicas is  smaller that the provided value. </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </max_ms>
               <discretization shape='' mode=''>
                  <help> Allows to specified non uniform time discretization as proposed in J. Chem. Phys. 134, 184107 (2011) </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </discretization>
               <alt_out>
                  <help> Alternative output:Prints different formatting of outputs for geometry, hessian and bead potential energies.
                                               All quantities are also accessible from typical i-pi output infrastructure.
                                               Default to 1, which prints every step. -1 will suppress the output (except the last one).
                                               Any other positive number will set the frequency (in steps) with which the quantities are
                                               written to file.
                                               The instanton geometry is printed in xyz format and the distances are in angrstroms
                                               The hessian is printed in one line with the following format:
                                               h1_1,h2_1,...,hN_1,   h2_2,h2_2,hN_2,   ....   ,h1_d,h2_d,...,hN_d.
                                               Where N represents the total number of replicas, d the number of dimension of each replica (3*n_atoms) and
                                               hi_j means the row j of the physical hessian corresponding to the replica i.
                                               The physical hessian uses a convention according to the positions convention used in  i-pi.
                                               Example of 2 particles, the first two rows of the physical hessian reads:
                                               'H_x1_x1, H_x1_y1, H_x1_z1, H_x1_x2, H_x1_y2,H_x1_z2'
                                               'H_x2_x1, H_x2_y1, H_x2_z1, H_x2_x2, H_x2_y2,H_x2_z2'  </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </alt_out>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default> instanton </default>
                  <dtype> string </dtype>
               </prefix>
               <delta>
                  <help> Initial stretch amplitude. </help>
                  <default> 0.1 </default>
                  <dtype> float </dtype>
               </delta>
               <hessian_init>
                  <help> How to initialize the hessian if it is not fully provided. </help>
                  <default> false </default>
                  <options> ['true', 'false'] </options>
                  <dtype> string </dtype>
               </hessian_init>
               <hessian shape='' mode=''>
                  <help> (Approximate) Hessian. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian>
               <hessian_update>
                  <help> How to update the hessian after each step. </help>
                  <default> powell </default>
                  <options> ['powell', 'recompute'] </options>
                  <dtype> string </dtype>
               </hessian_update>
               <hessian_asr>
                  <help> Removes the zero frequency vibrational modes depending on the symmerty of the system. </help>
                  <default> none </default>
                  <options> ['none', 'poly', 'crystal'] </options>
                  <dtype> string </dtype>
               </hessian_asr>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
               <old_direction shape='' mode=''>
                  <help> The previous direction in a CG or SD optimization. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                                       0 identity.
                                                       1 Use first member of position/gradient list.
                                                       2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 20 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <ls_options>
                  <help> "Options for line search methods. Includes:
                                  tolerance: stopping tolerance for the search,
                                  iter: the maximum number of iterations,
                                  step: initial step for bracketing,
                                  adaptive: whether to update initial step.
                                   </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.2 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
               </ls_options>
               <energy_shift units=''>
                  <help> Set the zero of energy. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy_shift>
               <hessian_final>
                  <help> Decide if we are going to compute the final big-hessian by finite difference. </help>
                  <default> false </default>
                  <options> ['false', 'true'] </options>
                  <dtype> string </dtype>
               </hessian_final>
            </instanton>
            <al6xxx_kmc mode=''>
               <help> Option for Al-6xxx KMC </help>
               <mode_help> The KMC algorithm to be used </mode_help>
               <mode_default> rfkmc </mode_default>
               <mode_options> ['rfkmc'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <geop mode=''>
                  <help> Option for geometry optimization step </help>
                  <mode_help> The geometry optimization algorithm to be used </mode_help>
                  <mode_default> lbfgs </mode_default>
                  <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ls_options>
                     <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                     <tolerance units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tolerance>
                     <iter>
                        <help> Generic input value </help>
                        <default> 100 </default>
                        <dtype> integer </dtype>
                     </iter>
                     <step units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> length </dimension>
                        <default> 0.001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </step>
                     <adaptive>
                        <help> Generic input value </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </adaptive>
                  </ls_options>
                  <exit_on_convergence>
                     <help> Terminates the simulation when the convergence criteria are met. </help>
                     <default> True </default>
                     <dtype> boolean </dtype>
                  </exit_on_convergence>
                  <tolerances>
                     <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
                     <energy units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 1e-07 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </energy>
                     <force units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> force </dimension>
                        <default> 0.0001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </force>
                     <position units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> length </dimension>
                        <default> 0.001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </position>
                  </tolerances>
                  <biggest_step>
                     <help> The maximum step size for (L)-BFGS line minimizations. </help>
                     <default> 100.0 </default>
                     <dtype> float </dtype>
                  </biggest_step>
                  <scale_lbfgs>
                     <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                     <default> 2 </default>
                     <dtype> integer </dtype>
                  </scale_lbfgs>
                  <corrections_lbfgs>
                     <help> The number of past vectors to store for L-BFGS. </help>
                     <default> 6 </default>
                     <dtype> integer </dtype>
                  </corrections_lbfgs>
                  <old_pos units='' shape='' mode=''>
                     <help> The previous positions in an optimization step. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_pos>
                  <old_pot units='' shape='' mode=''>
                     <help> The previous potential energy in an optimization step. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> energy </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_pot>
                  <old_force units='' shape='' mode=''>
                     <help> The previous force in an optimization step. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> force </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_force>
                  <old_direction shape='' mode=''>
                     <help> The previous direction in a CG or SD optimization. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_direction>
                  <invhessian_bfgs shape='' mode=''>
                     <help> Approximate inverse Hessian for BFGS, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </invhessian_bfgs>
                  <hessian_trm shape='' mode=''>
                     <help> Approximate Hessian for trm, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </hessian_trm>
                  <tr_trm units='' shape='' mode=''>
                     <help> The trust radius in trm. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </tr_trm>
                  <qlist_lbfgs shape='' mode=''>
                     <help> List of previous position differences for L-BFGS, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </qlist_lbfgs>
                  <glist_lbfgs shape='' mode=''>
                     <help> List of previous gradient differences for L-BFGS, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </glist_lbfgs>
               </geop>
               <nstep>
                  <help> The number of optimization steps. </help>
                  <default> 10 </default>
                  <dtype> integer </dtype>
               </nstep>
               <a0 units=''>
                  <help> FCC lattice parameter  </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </a0>
               <diffusion_barrier_al units=''>
                  <help> Barrier for vacancy diffusion in pure Al. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.01 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_barrier_al>
               <diffusion_prefactor_al units=''>
                  <help> Prefactor for vacancy diffusion in pure Al. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 2.4188843e-05 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_prefactor_al>
               <diffusion_barrier_mg units=''>
                  <help> Barrier for vacancy-assisted diffusion of Mg. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_barrier_mg>
               <diffusion_prefactor_mg units=''>
                  <help> Prefactor for vacancy-assisted diffusion of Mg. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_prefactor_mg>
               <diffusion_barrier_si units=''>
                  <help> Barrier for vacancy-assisted diffusion of Si. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_barrier_si>
               <diffusion_prefactor_si units=''>
                  <help> Prefactor for vacancy-assisted diffusion of Si. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_prefactor_si>
               <neval>
                  <help> The number of parallel force evaluators. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </neval>
               <ncell>
                  <help> The number of repeat cells in each direction. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </ncell>
               <nvac>
                  <help> The number of vacancies. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </nvac>
               <nsi>
                  <help> The number of silicon atoms. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </nsi>
               <nmg>
                  <help> The number of magnesium atoms. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </nmg>
               <idx shape='' mode=''>
                  <help> The position of the atoms on the lattice, relative to the canonical ordering. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </idx>
               <tottime units=''>
                  <help> Total KMC time elapsed  </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tottime>
               <ecache_file>
                  <help> Filename for storing/loading energy cache </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </ecache_file>
               <qcache_file>
                  <help> Filename for storing/loading positions cache </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </qcache_file>
               <max_cache_len>
                  <help> Maximum cache length before oldest entry is deleted </help>
                  <default> 1000 </default>
                  <dtype> integer </dtype>
               </max_cache_len>
            </al6xxx_kmc>
            <planetary mode=''>
               <help> Option for planetary model calculator </help>
               <mode_help> The constrained-centroid sampling mode.  </mode_help>
               <mode_default> md </mode_default>
               <mode_options> ['md'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
               <nsamples>
                  <help> Number of samples to accumulate for each planetary step. </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </nsamples>
               <stride>
                  <help> How often the planetary calculation should actually be triggered. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </stride>
               <nbeads>
                  <help> Number of beads for centroid-constrained dynamics (default same as master trajectory) </help>
                  <default> -1 </default>
                  <dtype> integer </dtype>
               </nbeads>
               <screen units=''>
                  <help> Screening parameter for path-integral frequency matrix. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </screen>
            </planetary>
         </motion>
      </motion>
      <beads natoms='' nbeads=''>
         <help> Describes the bead configurations in a path integral simulation. </help>
         <natoms_help> The number of atoms. </natoms_help>
         <nbeads_help> The number of beads. </nbeads_help>
         <natoms_default> 0 </natoms_default>
         <nbeads_default> 0 </nbeads_default>
         <natoms_dtype> integer </natoms_dtype>
         <nbeads_dtype> integer </nbeads_dtype>
         <q units='' shape='' mode=''>
            <help> The positions of the beads. In an array of size [nbeads, 3*natoms]. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> length </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </q>
         <p units='' shape='' mode=''>
            <help> The momenta of the beads. In an array of size [nbeads, 3*natoms]. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> momentum </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </p>
         <m units='' shape='' mode=''>
            <help> The masses of the atoms, in the format [m1, m2, ... ]. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> mass </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </m>
         <names shape='' mode=''>
            <help> The names of the atoms, in the format [name1, name2, ... ]. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> string </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </names>
      </beads>
      <normal_modes transform='' propagator=''>
         <help> Deals with the normal mode transformations, including the adjustment of bead masses to give the desired ring polymer normal mode frequencies if appropriate. Takes as arguments frequencies, of which different numbers must be specified and which are used to scale the normal mode frequencies in different ways depending on which 'mode' is specified. </help>
         <transform_help> Specifies whether to calculate the normal mode transform using a fast Fourier transform or a matrix multiplication. For small numbers of beads the matrix multiplication may be faster. </transform_help>
         <propagator_help> How to propagate the free ring polymer dynamics. Cayley transform is not exact but is strongly stable and avoid potential resonance issues. A bab scheme performs numerical verlet type propagation. All three options work for distinguishable particles. Only the bab propagator can be used with bosonic particles. </propagator_help>
         <transform_default> fft </transform_default>
         <propagator_default> exact </propagator_default>
         <transform_options> ['fft', 'matrix'] </transform_options>
         <propagator_options> ['exact', 'cayley', 'bab'] </propagator_options>
         <transform_dtype> string </transform_dtype>
         <propagator_dtype> string </propagator_dtype>
         <frequencies units='' shape='' mode='' style=''>
            <help> Specifies normal mode frequencies for a (closed path) calculation </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <style_help> Specifies the technique to be used to calculate the dynamical masses.
                                                'rpmd' simply assigns the bead masses the physical mass.
                                                'manual' sets all the normal mode frequencies except the centroid normal mode manually.
                                                'pa-cmd' takes an argument giving the frequency to set all the non-centroid normal modes to.
                                                'wmax-cmd' is similar to 'pa-cmd', except instead of taking one argument it takes two
                                                      ([wmax,wtarget]). The lowest-lying normal mode will be set to wtarget for a
                                                      free particle, and all the normal modes will coincide at frequency wmax.  </style_help>
            <dimension> frequency </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <style_default> rpmd </style_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <style_options> ['pa-cmd', 'wmax-cmd', 'manual', 'rpmd'] </style_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
            <style_dtype> string </style_dtype>
         </frequencies>
         <open_paths shape='' mode=''>
            <help> Indices of the atoms whose path should be opened (zero-based). </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </open_paths>
         <bosons shape='' mode=''>
            <help> Indices of the atoms that are bosons (zero-based). </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </bosons>
         <nmts>
            <help> The number of iterations to perform one bab step. </help>
            <default> 1 </default>
            <dtype> integer </dtype>
         </nmts>
      </normal_modes>
      <cell units='' shape='' mode=''>
         <help> Deals with the cell parameters. Takes as array which can be used to initialize the cell vector matrix. </help>
         <units_help> The units the input data is given in. </units_help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <dimension> length </dimension>
         <default>
            [0. 0. 0. 0. 0. 0. 0. 0. 0.]
         </default>
         <units_default> automatic </units_default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </cell>
   </system>
   <system_template>
      <help> Generic input value </help>
      <template>
         <help>  A string that will be read verbatim containing the model for a system to be generated </help>
         <dtype> string </dtype>
      </template>
      <labels shape='' mode=''>
         <help>  A list of strings that should be substituted in the template to create multiple systems  </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> string </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </labels>
      <instance shape='' mode=''>
         <help>  A list of strings that should the labels creating one system instance  </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> string </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </instance>
   </system_template>
   <ffsocket mode='' matching='' name='' pbc='' threaded=''>
      <help> Deals with the assigning of force calculation jobs to different driver codes, and collecting the data, using a socket for the data communication. </help>
      <mode_help> Specifies whether the driver interface will listen onto a internet socket [inet] or onto a unix socket [unix]. </mode_help>
      <matching_help> Specifies whether requests should be dispatched to any client, or automatically matched to the same client when possible [auto]. </matching_help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial. Should be set to True for FFSockets </threaded_help>
      <mode_default> inet </mode_default>
      <matching_default> auto </matching_default>
      <pbc_default> True </pbc_default>
      <threaded_default> True </threaded_default>
      <mode_options> ['unix', 'inet'] </mode_options>
      <matching_options> ['auto', 'any'] </matching_options>
      <mode_dtype> string </mode_dtype>
      <matching_dtype> string </matching_dtype>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <address>
         <help> This gives the server address that the socket will run on. </help>
         <default> localhost </default>
         <dtype> string </dtype>
      </address>
      <port>
         <help> This gives the port number that defines the socket. </help>
         <default> 65535 </default>
         <dtype> integer </dtype>
      </port>
      <slots>
         <help> This gives the number of client codes that can queue at any one time. </help>
         <default> 4 </default>
         <dtype> integer </dtype>
      </slots>
      <exit_on_disconnect>
         <help> Determines if i-PI should quit when a client disconnects. </help>
         <default> False </default>
         <dtype> boolean </dtype>
      </exit_on_disconnect>
      <timeout>
         <help> This gives the number of seconds before assuming a calculation has died. If 0 there is no timeout. </help>
         <default> 0.0 </default>
         <dtype> float </dtype>
      </timeout>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.01 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffsocket>
   <fflj name='' pbc='' threaded=''>
      <help> Simple, internal LJ evaluator without cutoff, neighbour lists or minimal image convention.
                   Expects standard LJ parameters, e.g. { eps: 0.1, sigma: 1.0 }.  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.01 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </fflj>
   <ffdebye name='' pbc='' threaded=''>
      <help> Harmonic energy calculator  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <hessian shape='' mode=''>
         <help> Specifies the Hessian of the harmonic potential (atomic units!) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default> [ ] </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </hessian>
      <x_reference units='' shape='' mode=''>
         <help> Minimum-energy configuration for the harmonic potential </help>
         <units_help> The units the input data is given in. </units_help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <dimension> length </dimension>
         <default> [ ] </default>
         <units_default> automatic </units_default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </x_reference>
      <v_reference units=''>
         <help> Zero-value of energy for the harmonic potential </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> energy </dimension>
         <default> 0.0 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </v_reference>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.01 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffdebye>
   <ffplumed name='' pbc='' threaded=''>
      <help>  Direct PLUMED interface  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <init_file mode='' bead='' cell_units=''>
         <help> This describes the location to read the reference structure file from. </help>
         <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 'chk' stands for initialization from a checkpoint file. </mode_help>
         <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
         <cell_units_help> The units for the cell dimensions. </cell_units_help>
         <default>  </default>
         <mode_default> chk </mode_default>
         <bead_default> -1 </bead_default>
         <cell_units_default> automatic </cell_units_default>
         <mode_options> ['xyz', 'pdb', 'chk'] </mode_options>
         <dtype> string </dtype>
         <mode_dtype> string </mode_dtype>
         <bead_dtype> integer </bead_dtype>
         <cell_units_dtype> string </cell_units_dtype>
      </init_file>
      <plumeddat>
         <help> The PLUMED input file </help>
         <default> plumed.dat </default>
         <dtype> string </dtype>
      </plumeddat>
      <plumedstep>
         <help> The current step counter for PLUMED calls </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </plumedstep>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.01 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffplumed>
   <ffyaff name='' pbc='' threaded=''>
      <help> Uses a Yaff force field to compute the forces. </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <yaffpara>
         <help> This gives the file name of the Yaff input parameter file. </help>
         <default> parameters.txt </default>
         <dtype> string </dtype>
      </yaffpara>
      <yaffsys>
         <help> This gives the file name of the Yaff input system file. </help>
         <default> system.chk </default>
         <dtype> string </dtype>
      </yaffsys>
      <yafflog>
         <help> This gives the file name of the Yaff output log file. </help>
         <default> yaff.log </default>
         <dtype> string </dtype>
      </yafflog>
      <rcut>
         <help> This gives the real space cutoff used by all pair potentials in atomic units. </help>
         <default> 18.89726133921252 </default>
         <dtype> float </dtype>
      </rcut>
      <alpha_scale>
         <help> This gives the alpha parameter in the Ewald summation based on the real-space cutoff: alpha = alpha_scale / rcut. Higher values for this parameter imply a faster convergence of the reciprocal terms, but a slower convergence in real-space. </help>
         <default> 3.5 </default>
         <dtype> float </dtype>
      </alpha_scale>
      <gcut_scale>
         <help> This gives the reciprocale space cutoff based on the alpha parameter: gcut = gcut_scale * alpha. Higher values for this parameter imply a better convergence in the reciprocal space. </help>
         <default> 1.1 </default>
         <dtype> float </dtype>
      </gcut_scale>
      <skin>
         <help> This gives the skin parameter for the neighborlist. </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </skin>
      <smooth_ei>
         <help> This gives the flag for smooth truncations for the electrostatic interactions. </help>
         <default> False </default>
         <dtype> boolean </dtype>
      </smooth_ei>
      <reci_ei>
         <help> This gives the method to be used for the reciprocal contribution to the electrostatic interactions in the case of periodic systems. This must be one of 'ignore' or 'ewald'. The 'ewald' option is only supported for 3D periodic systems. </help>
         <default> ewald </default>
         <dtype> string </dtype>
      </reci_ei>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.01 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffyaff>
   <ffsgdml name='' pbc='' threaded=''>
      <help> A SGDML energy calculator  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <sGDML_model>
         <help> This gives the file name of the sGDML model. </help>
         <dtype> string </dtype>
      </sGDML_model>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.01 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: all (corresponding to -1) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffsgdml>
</simulation>
